{
  "id": "kb-207",
  "title": "ConfigMap and Secret Troubleshooting",
  "category": "troubleshooting",
  "tags": ["configmap", "secret", "configuration", "environment", "volume", "mount"],
  "summary": "Guide for debugging ConfigMap and Secret issues including mounting, updates, and encoding",

  "basics": {
    "description": "How ConfigMaps and Secrets work in Kubernetes",
    "concepts": {
      "configmap": {
        "description": "Stores non-sensitive configuration data",
        "usage": ["Environment variables", "Volume mounts", "Command arguments"]
      },
      "secret": {
        "description": "Stores sensitive data (base64 encoded, not encrypted by default)",
        "types": ["Opaque", "kubernetes.io/tls", "kubernetes.io/dockerconfigjson"]
      },
      "mounting_options": {
        "env_var": "Single key as environment variable",
        "env_from": "All keys as environment variables",
        "volume": "Mount as files in container"
      }
    },
    "commands": [
      {
        "command": "kubectl get configmap -n <ns>",
        "description": "List ConfigMaps in namespace"
      },
      {
        "command": "kubectl get secret -n <ns>",
        "description": "List Secrets in namespace"
      },
      {
        "command": "kubectl describe configmap <name> -n <ns>",
        "description": "View ConfigMap details and data"
      },
      {
        "command": "kubectl get secret <name> -n <ns> -o jsonpath='{.data.<key>}' | base64 -d",
        "description": "Decode a specific secret value"
      }
    ]
  },

  "common_errors": [
    {
      "name": "Pod not starting - ConfigMap/Secret not found",
      "error_patterns": [
        "configmap not found",
        "secret not found",
        "couldn't find key"
      ],
      "symptoms": [
        "Pod stuck in ContainerCreating",
        "Events show missing ConfigMap or Secret"
      ],
      "likely_causes": [
        "ConfigMap/Secret doesn't exist",
        "Name typo in pod spec",
        "Wrong namespace"
      ],
      "diagnostic_commands": [
        "kubectl describe pod <pod> -n <ns>",
        "kubectl get configmap,secret -n <ns>",
        "kubectl get pod <pod> -n <ns> -o yaml | grep -A5 'configMap\\|secret'"
      ],
      "fix_steps": [
        "Create missing ConfigMap/Secret",
        "Fix name reference in pod spec",
        "Ensure ConfigMap/Secret in same namespace as pod"
      ]
    },
    {
      "name": "Environment variable not available in container",
      "error_patterns": [
        "Environment variable empty",
        "env: unbound variable"
      ],
      "symptoms": [
        "Application fails due to missing config",
        "echo $VAR returns empty"
      ],
      "likely_causes": [
        "Key doesn't exist in ConfigMap/Secret",
        "envFrom vs env syntax issue",
        "Pod needs restart after ConfigMap update"
      ],
      "diagnostic_commands": [
        "kubectl exec <pod> -- env | grep <VAR>",
        "kubectl get configmap <name> -n <ns> -o yaml",
        "kubectl get pod <pod> -n <ns> -o yaml | grep -A10 env"
      ],
      "fix_steps": [
        "Verify key exists: kubectl get configmap <name> -o jsonpath='{.data}'",
        "Check correct envFrom/env syntax",
        "Restart pod to pick up changes: kubectl rollout restart deploy <name>"
      ],
      "example": {
        "description": "Correct environment variable from ConfigMap",
        "yaml": "env:\n- name: MY_VAR\n  valueFrom:\n    configMapKeyRef:\n      name: my-config\n      key: my-key"
      }
    },
    {
      "name": "Mounted files not updating",
      "error_patterns": [
        "Old config still being used",
        "Changes not reflected"
      ],
      "symptoms": [
        "ConfigMap updated but pod uses old values",
        "Application not picking up new config"
      ],
      "likely_causes": [
        "subPath mounts don't auto-update",
        "Application caches config at startup",
        "Kubelet sync delay (up to 1 minute)"
      ],
      "diagnostic_commands": [
        "kubectl exec <pod> -- cat /path/to/mounted/file",
        "kubectl get configmap <name> -o yaml",
        "kubectl get pod <pod> -o yaml | grep subPath"
      ],
      "fix_steps": [
        "Avoid subPath if auto-update needed",
        "Implement config reload in application",
        "Use immutable ConfigMaps with hash in name",
        "Trigger pod restart with annotation change"
      ],
      "note": "Volume-mounted ConfigMaps update automatically (except subPath), but app may need to watch for file changes"
    },
    {
      "name": "Secret data encoding issues",
      "error_patterns": [
        "illegal base64 data",
        "Incorrect padding"
      ],
      "symptoms": [
        "Secret creation fails",
        "Decoded value is garbage"
      ],
      "likely_causes": [
        "Data not base64 encoded when using data field",
        "Double encoding",
        "Line breaks in base64 string"
      ],
      "diagnostic_commands": [
        "echo '<value>' | base64 -d",
        "kubectl get secret <name> -o jsonpath='{.data}'"
      ],
      "fix_steps": [
        "Use stringData field for automatic encoding",
        "Ensure single base64 encoding",
        "Remove newlines from base64 strings"
      ],
      "example": {
        "description": "Using stringData for automatic encoding",
        "yaml": "apiVersion: v1\nkind: Secret\nmetadata:\n  name: my-secret\nstringData:\n  password: my-plain-text-password"
      }
    },
    {
      "name": "Permission denied on mounted files",
      "error_patterns": [
        "Permission denied",
        "Cannot read file"
      ],
      "symptoms": [
        "Application cannot read mounted ConfigMap/Secret",
        "Files exist but not accessible"
      ],
      "likely_causes": [
        "Container running as non-root can't read files",
        "defaultMode not set correctly",
        "fsGroup not matching container user"
      ],
      "diagnostic_commands": [
        "kubectl exec <pod> -- ls -la /path/to/mount",
        "kubectl exec <pod> -- id",
        "kubectl get pod <pod> -o yaml | grep -A5 securityContext"
      ],
      "fix_steps": [
        "Set appropriate defaultMode (e.g., 0644)",
        "Configure fsGroup in securityContext",
        "Use initContainer to fix permissions"
      ],
      "example": {
        "description": "Setting file permissions on mount",
        "yaml": "volumes:\n- name: config\n  secret:\n    secretName: my-secret\n    defaultMode: 0400"
      }
    },
    {
      "name": "Too large ConfigMap/Secret",
      "error_patterns": [
        "etcd value size exceeded",
        "Request entity too large"
      ],
      "symptoms": [
        "Cannot create or update ConfigMap/Secret",
        "1MB limit exceeded"
      ],
      "likely_causes": [
        "ConfigMap/Secret data exceeds 1MB limit",
        "Large files being stored directly"
      ],
      "fix_steps": [
        "Split into multiple ConfigMaps/Secrets",
        "Use external config store (Vault, AWS Secrets Manager)",
        "Store large files in persistent storage or container image",
        "Compress data if possible"
      ]
    }
  ],

  "patterns_and_tips": {
    "config_reloading": {
      "description": "Techniques for config updates without restart",
      "approaches": [
        {
          "method": "Checksum annotation",
          "description": "Add ConfigMap hash as pod annotation to trigger rolling update",
          "example": "annotations:\n  checksum/config: {{ include (print $.Template.BasePath \"/configmap.yaml\") . | sha256sum }}"
        },
        {
          "method": "File watcher",
          "description": "Application watches mounted file for changes",
          "tools": ["fsnotify", "inotify"]
        },
        {
          "method": "Reloader",
          "description": "Use stakater/Reloader to auto-restart on ConfigMap changes",
          "annotation": "reloader.stakater.com/auto: 'true'"
        }
      ]
    },
    "immutable_configs": {
      "description": "Create new ConfigMap per change with hash suffix",
      "benefits": [
        "Clear audit trail",
        "Easy rollback",
        "Atomic updates"
      ],
      "pattern": "configmap-name-abc123 where abc123 is content hash"
    }
  },

  "debugging_workflow": {
    "env_var_missing": [
      "kubectl exec <pod> -- env | sort → List all env vars",
      "kubectl get configmap <name> -o yaml → Check data exists",
      "kubectl get pod <pod> -o yaml → Check envFrom/env config",
      "Restart pod if ConfigMap was updated after pod started"
    ],
    "mount_issues": [
      "kubectl describe pod <pod> → Check volume mounts",
      "kubectl exec <pod> -- ls -la /mount/path → Check files exist",
      "kubectl exec <pod> -- cat /mount/path/file → Read content",
      "Compare with: kubectl get configmap <name> -o jsonpath='{.data}'"
    ]
  },

  "best_practices": {
    "design": [
      "Use Secrets for sensitive data (passwords, API keys)",
      "Enable encryption at rest for Secrets",
      "Use immutable ConfigMaps for stability",
      "Version ConfigMaps using hash suffix"
    ],
    "operations": [
      "Never log Secret values",
      "Use RBAC to limit Secret access",
      "Consider external secret management (Vault, ESO)",
      "Test config changes in staging first"
    ]
  }
}
